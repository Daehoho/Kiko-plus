---
layout: post
title: "[OS] - 운영체제 키워드(1)"
description: "Computer Science"
date: 2018-12-15
tags: [O/S, Kernel]
comments: false
share: true
---

운영체제와 리눅스 커널을 공부하면서 헷갈렸던 키워드들에 대해 정리해보겠습니다.

---

### 커널(Kernel) 

커널은 본질적으로 우리가 흔히 아는 프로그램입니다. 하지만 일반적인 프로그램과 다른점은 'Memory Resident'라는 점입니다. 즉 메모리에 항상 상주해있는 프로그램입니다.

커널이 아닌 프로그램들은 Disk에 있다가 필요할때 메모리에 올려서 사용하기 때문에 'Disk Resident'라고 표현합니다. 그리고 이러한 커널을 제외한 프로그램을 유틸리티(Utility) 라고 칭합니다.


### 커널과 쉘, 유틸리티의 관계

우선 리눅스의 경우 멀티 유저 시스템이므로 여러 사용자가 하나의 자원을 가지고 사용하게 된다는 점을 알고 아래 내용을 봐야합니다.

(1) 시스템 부팅 - 메인 메모리에 커널이 올라온다.
(2) User A 접속 - 메인 메모리에 쉘이 올라온다.
(3) 쉘이 User A가 커맨드를 입력하기를 대기
(4) User A 커맨드 입력 - 쉘이 커맨드에 대응하는 유틸리티를 디스크로 부터 가져와 실행(메모리에 적재)

시스템이 부팅되고 이용자가 접속할때마다 (2),(3),(4) 의 과정을 통해 커널, 쉘, 유틸리티의 관계가 형성됨을 알 수 있습니다.

커널은 운영체제 자체이며 항상 메모리에 상주해있고 나머지 프로그램인 유틸리티는 디스크에 상주합니다. 이러한 유틸리티를 교통정리하는 것이 쉘의 역할입니다.

### System Call

위에서도 말했듯이 리눅스는 멀티 유저 시스템이여서 서로 다른 유저간에 대해서 보안이 매우 중요합니다. 

이러한 보안문제를 해결하기 위해 리눅스는 사전방지(Prevent)하기 위해 'I/O instruction'을 막는 방법을 사용하였습니다.

이는 쉘은 포함한 다른 일반 프로그램이 I/O를 수행하는 순간 CPU 사용권한을 바로 뺏기게 됩니다.

그렇기 때문에 I/O instruction을 수행할때는 커널이 가지고 있는 Fucntion에게 부탁하는 방식으로 되어있습니다.

이 부탁하는 과정을 'System Call'이라고 합니다.

### 커널모드, 유저모드

'System Call'을 통한 I/O Instruction이 합법적인 것인지 검사한 후에 I/O를 대신 진행합니다. 이러한 구조를 위해 하드웨어적인 요소를 도입하였는데 CPU에 하나의 Binary Bit를 도입하였습니다.

이러한 bit를 'mode bit'라고 칭하고 이 bit의 값을 통해 유저 모드와 커널 모들 구분하게 됩니다.

mode bit가 유저모드일 때, CPU가 접근하는 메모리 주소가 실행 중인 프로그램의 범위 밖이거나 I/O Instruction등의 금지된 실행을 하려고 하면 CPU 사용권을 뺏기게 된다.

반대로 커널모드였던 경우는 위와같은 검증 절차를 거치지 않아도 됩니다.

하지만 여기서 의문점은 우리가 작성하는 프로그램에서 printf등의 함수를 통해 I/O instruction을 이용하는 것을 알 수 있습니다.

어떻게 그런지 알아보자면 소스코드에서 I/O instruction을 수행하게 되면 컴파일러를 통해 바이너리 파일에서는 chmodk라는 명령을 수행하게 됩니다.

chmodk는 Change CPU protection mode to Kernel 라는 의미입니다. chmodk 명령어가 수행되면 더 이상 유저모드에서 실행할 수 없게 만듭니다.

이것을 trap이라고 하며 이를 통해 트랩 핸들러 루틴 (트랩을 처리하는 루틴)으로 진입하는데, 이 루틴은 커널안에서 처리됩니다. 그리고 이를 통해 System Call을 수행하게 됩니다.